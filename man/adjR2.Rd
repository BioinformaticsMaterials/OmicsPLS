% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/O2PLS.R
\name{adjR2}
\alias{adjR2}
\title{Gridwise adjusted R2 for O2PLS}
\usage{
adjR2(X, Y, a = 1:2, a2 = 1, b2 = 1, func = o2m_stripped, parall = F,
  cl = NULL)
}
\arguments{
\item{X}{Numeric matrix.}

\item{Y}{Numeric matrix.}

\item{a}{Vector of integers. Contains the numbers of joint components.}

\item{a2}{Vector of integers. Contains the numbers of orthogonal components in \eqn{X}.}

\item{b2}{Vector of integers. Contains the numbers of orthogonal components in \eqn{Y}.}

\item{func}{Function to fit the O2PLS model with. Only \code{\link{o2m}} and \code{\link{o2m_stripped}} are supported.}

\item{parall}{Integer. Should a parallel cluster be set up using package \code{parallel} (Windows)? Best is to leave it to \code{FALSE}.}

\item{cl}{Object of class "\code{cluster}". If parall is \code{TRUE} and \code{cl} is not \code{NULL}, calculations are parallelized over workers in cl.}
}
\value{
Matrix with two rows:
\item{adjR2X}{Contains the joint R2 in X}
\item{adjR2Y}{Contains the joint R2 in Y}
}
\description{
For (a grid of) values for \code{a}, \code{nx} and \code{ny}, \code{loocv} calculates the R2 of the joint part. Parallel computing is supported on Windows with package \code{parallel}.
}
\details{
The use of this function is to calculate the R2 of the joint part, while varying the number of orthogonal components. Adding more joint components will increase the R2!

A parallelized version is built in -tested on windows-, use package \code{parallel} and set \code{parall=TRUE} to activate this. There should not be already a cluster object with the name \code{cl}.
In case of some error, don't forget to invoke \code{stopCluster(cl)} to end the cluster. See Task Manager (Windows) to verify that the workers are spanned/ended.
}
\examples{
result=adjR2(matrix(rnorm(10*100),ncol=10),matrix(rnorm(10*100),ncol=10),a=1:3,a2=0:1,b2=0:1,func=o2m_stripped)
names_for_a=sapply(1:3,function(i){paste("a",i,sep="=")})
names_for_a2=sapply(0:1,function(i){paste("a2",i,sep="=")})
names_for_b2=sapply(0:1,function(i){paste("b2",i,sep="=")})
array(unlist(result[1,]),dim=c(3,2,2),dimnames=list(names_for_a,names_for_a2,names_for_b2))
}

